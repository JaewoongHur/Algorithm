# [Bronze I] Elias Omega Coding - 5653 

[문제 링크](https://www.acmicpc.net/problem/5653) 

### 성능 요약

메모리: 11428 KB, 시간: 72 ms

### 분류

수학, 구현, 사칙연산

### 제출 일자

2026년 2월 12일 17:50:11

### 문제 설명

<p>Elias code can be used to efficiently encode positive integers when there is no prior information about the cardinality of the integers to be encoded and it is known that the probability of getting a large integer is smaller than or equal to the probability of getting a small integer. For practical reasons, however, in this contest we do pose a limit on the size of the input integers. For the same reason we restrict the input integer to be greater than 1.</p>

<p>Elias developed three variants of the code: the Elias gamma, Elias delta, and Elias omega coding methods. This problem presents the Elias gamma and Elias omega methods and calls for implementing the Elias omega code. The following is a background, definition, and illustration of the problem.</p>

<p>Suppose that Alice wants to transmit a positive integer n to Bob through a binary channel and let β(n) stand for the binary representation of n. If Bob knows |β(n)| (the number of bits required for the binary representation of n) in advance, then Alice should use β(n) for the transmission. On the other hand, if Bob does not have this information, then Alice can first send |β(n)|, using efficient and distinguishable encoding, then she can send the actual beta code F<sub>1</sub> = β(n). The end result is a two field code <F<sub>1</sub>, F<sub>2</sub>>.</p>

<p>Elias code and its variants differ in the way they encode these two pieces of information (F<sub>1</sub> and F<sub>2</sub>). The main difference between variants lies in the representation of F<sub>1</sub>. This may imply modifications in the representation of F<sub>1</sub>. In addition, some of the variants apply repetition or recursion to the representation of F<sub>1</sub>. We use a specific variant specified below.</p>

<p>Formally, in Elias gamma coding, a positive integer n is encoded using two concatenated bit fields. The first field, the prefix, contains [log<sub>2</sub>n] bits of 0 ( [x] is the floor of x). The second field, the postfix, is the actual binary representation of n using [log<sub>2</sub>n]+1 bits. For example, the binary representation of the decimal number 9 is 1001. Under Elias coding 9 is encoded as 0001001. The first three leading zeros denote that four bits are required for the binary representation of 9. The next four bits contain the binary representation of 9. Elias delta code applies the gamma code to the prefix([log<sub>2</sub>n]) of the gamma code and Elias omega code applies a recursion over the prefix Elias gamma representation of [log<sub>2</sub>n].</p>

<p>To further illustrate the Elias omega code, consider the integer 536870907. The binary representation of this integer is 1 1111 1111 1111 1111 1111 1111 1011 which is required 29 bits. Hence, in the first step it is encoded as follows:</p>

<p><F<sub>1</sub>, F<sub>2</sub>> = <0000 0000 0000 0000 0000 0000 0000, 1 1111 1111 1111 1111 1111 1111 1011></p>

<p>where blanks, dots, commas, and brackets, are inserted for readability.</p>

<p>To emphasize, for this contest the recursion stops when the first field of a recursive stage contains one 0.</p>

<p>Looking at all the bits generated by all the steps and using β(n) to denote the binary representation of n, we have:</p>

<ol style="list-style-type: lower-alpha;">
	<li><28 0’s, β(536870907)> = <0000 0000 0000 0000 0000 0000 0000, 1 1111 1111 1111 1111 1111 1111 1011></li>
	<li><<4 0’s, β(28)>, β(536870907)> = <<0000, 1 1100>, 1 1111 1111 1111 1111 1111 1111 1011></li>
	<li><<<2 0’s, β(4)>, β(28)> , β(536870907)> = <<<00, 100>, 1 1100>, 1 1111 1111 1111 1111 1111 1111 1011></li>
	<li><<<<one 0, β(2)>, β(4)>, β(28)>, β(536870907)> = <<<<0, 10>, 100>, 1 1100>, 1 1111 1111 1111 1111 1111 1111 1011></li>
</ol>

<p>Taking away all the blanks, dots, commas, and brackets we get that the Elias omega code of 536870907 is: 0101001110011111111111111111111111111011. This code is distinguishable (uniquely decodable). It can be decoded in a unique way and yield back the number 536870907.</p>

<p>Given some positive integers in the range of 2 – 2x10<sup>9</sup>, you are to write a program to produce the Elias omega codes for these integers.</p>

### 입력 

 <p>The input contains positive integers each in a separate line. Each integer is in between 2 - 2,000,000,000, inclusive. The end of input is indicated by a zero. The input can contain up to one hundred lines.</p>

### 출력 

 <p>The output consists of lines each corresponding to an input integer except the last zero. Each line contains the Elias omega code of each input integer. The output should not contain any blanks or blank lines.</p>

